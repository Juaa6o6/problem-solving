# [Bronze I] 단어 공부 - 1157 

[문제 링크](https://www.acmicpc.net/problem/1157) 

### 성능 요약

메모리: 34368 KB, 시간: 204 ms

### 분류

구현, 문자열

### 제출 일자

2026년 1월 14일 23:55:50

### 문제 설명

<p>알파벳 대소문자로 된 단어가 주어지면, 이 단어에서 가장 많이 사용된 알파벳이 무엇인지 알아내는 프로그램을 작성하시오. 단, 대문자와 소문자를 구분하지 않는다.</p>

### 입력 

 <p>첫째 줄에 알파벳 대소문자로 이루어진 단어가 주어진다. 주어지는 단어의 길이는 1,000,000을 넘지 않는다.</p>

### 출력 

 <p>첫째 줄에 이 단어에서 가장 많이 사용된 알파벳을 대문자로 출력한다. 단, 가장 많이 사용된 알파벳이 여러 개 존재하는 경우에는 ?를 출력한다.</p>

### 메모
```python
A = str(input())
a = A.upper()

cnt = []
alpha = [chr(i) for i in range(ord('A'),ord('Z')+1)]

for j in alpha:

    cnt.append(a.count(j))

if cnt.count(max(cnt)) >= 2:
    print("?")

else :
    result = cnt.index(max(cnt))
    print(chr(result+65))

```

두 코드 사이의 속도 차이가 발생하는 핵심 원인은 **'알고리즘의 시간 복잡도(Big-O)'와 '프로그래밍 언어의 구현상 오버헤드(Overhead)' 간의 괴리**에 있습니다.

일반적으로 알고리즘 이론에서는 위의 코드가 더 효율적이어야 하지만, 파이썬(Python)이라는 언어의 특성상 아래 코드가 더 빠르게 동작하는 경우가 많습니다. 그 이유는 다음과 같습니다.

---

#### 1. 첫 번째 코드 (반복문 사용) 분석

이론적 시간 복잡도:

첫 번째 코드는 문자열을 처음부터 끝까지 **단 한 번** 순회합니다. 이론적으로는 가장 이상적인 방법입니다. 그러나 파이썬 인터프리터의 특성 때문에 실제 수행 시간은 느려질 수 있습니다.

* **파이썬의 for 문 오버헤드:** 파이썬은 C나 C++ 같은 컴파일 언어와 달리, 코드를 한 줄씩 해석해서 실행하는 인터프리터 언어입니다.
* **반복의 비용:** `for w in st:` 구문에서 문자열의 길이만큼 반복할 때마다 다음 작업을 수행합니다.
1. 문자 하나(`w`)를 가져옵니다.
2. `ord(w)` 함수를 호출하여 아스키코드로 변환합니다.
3. 리스트 `lst`의 특정 인덱스에 접근합니다.
4. 값을 1 증가시키고 다시 저장합니다.


* **결과:** 문자열이 100만 자라면, 이 느린 파이썬 레벨의 연산 과정을 100만 번 수행해야 하므로 전체 속도가 저하됩니다.

#### 2. 두 번째 코드 (`count` 메서드 사용) 분석

이론적 시간 복잡도:

두 번째 코드는 알파벳 개수(26개)만큼 반복하며, 매번 `count()` 메서드를 통해 문자열 전체를 훑습니다. 즉, 첫 번째 코드보다 26배 더 많이 문자열을 확인합니다. 그럼에도 불구하고 빠른 이유는 다음과 같습니다.

* **C로 구현된 내장 메서드:** 파이썬의 `str.count()` 메서드는 내부적으로 **C언어**로 최적화되어 구현되어 있습니다.
* **속도 차이:** 파이썬의 `for` 문을 통해 문자 하나하나를 꺼내 비교하는 것보다, C언어 레벨에서 메모리를 훑으며 문자를 세는 속도가 압도적으로 빠릅니다.
* **결과:** 문자열을 26번 훑더라도, C언어의 고속 연산 덕분에 파이썬 for 문으로 1번 훑는 것보다 총 소요 시간이 더 짧게 걸리는 현상이 발생합니다.

#### 3. 요약 및 비교

| 구분 | 첫 번째 코드 (Loop) | 두 번째 코드 (Count) |
| --- | --- | --- |
| **순회 횟수** | 문자열 길이만큼 1회 () | 알파벳 개수만큼 26회 () |
| **실행 주체** | **Python 인터프리터** (상대적으로 느림) | **C언어 내부 함수** (매우 빠름) |
| **주요 병목** | 반복문 실행 시마다 발생하는 인터프리터 오버헤드 | 문자열 길이가 극단적으로 길어질 경우의 반복 횟수 |
| **특징** | 로직 자체는 효율적이나 언어 특성상 느림 | 로직은 비효율적이나 구현 최적화로 빠름 |

---

#### 4. 더 나은 해결책

이 문제(백준 1157번 유형)에서 성능과 가독성을 모두 잡는 가장 '파이썬스러운(Pythonic)' 방법은 표준 라이브러리인 `collections.Counter`를 사용하는 것입니다.

`Counter`는 내부적으로 C로 최적화된 해시 테이블을 사용하여 문자열을 한 번만 순회()하면서도 `count()`보다 훨씬 효율적으로 빈도수를 계산합니다.

```python
import sys
from collections import Counter

# 입력 속도 가속
st = sys.stdin.readline().strip().upper()

if not st:
    print("?") # 예외 처리
else:
    # 가장 빈도수가 높은 문자 계산
    counts = Counter(st).most_common(2) 

    if len(counts) > 1 and counts[0][1] == counts[1][1]:
        print("?")
    else:
        print(counts[0][0])

```

 `most_common(2)`는 '가장 많이 나온 문자 상위 2등까지'를 뽑아서 **리스트(List)** 안에 **튜플(Tuple)** 형태로 돌려줍니다.

---

### 1. 데이터의 생김새

예를 들어 `st = "MISSISSIPPI"`라는 문자열이 있다고 가정해 봅시다.
`Counter(st).most_common(2)`를 실행하면 결과(`counts`)는 다음과 같이 나옵니다.

```python
# 결과 예시 (리스트 안에 튜플이 들어있는 형태)
counts = [('S', 4), ('I', 4)]
```

이 구조는 **`[(1등문자, 1등개수), (2등문자, 2등개수)]`** 순서입니다.

알고리즘 문제 풀 때 문자열 개수 셀 일이 정말 많은데, 이 패턴은 거의 공식처럼 쓰이니 익혀두시면 아주 편합니다.

